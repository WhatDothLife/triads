* Deprecated
** TODO
*** TODO Remove open files when crashing
*** TODO Use &str, &[T] or &T to allow for more generic code.
*** TODO Implement finding Core of Graph

** Code
#+begin_src rustic
fn ac_init<V0, V1>(
    g0: &AdjacencyList<V0>,
    g1: &AdjacencyList<V1>,
    f: &mut HashMap<V0, Set<V1>>,
    m: &mut HashMap<V0, HashSet<V1>>,
    counter: &mut HashMap<(V0, V0), HashMap<V1, u32>>,
    s_ac: &mut HashMap<(V0, V1), Vec<(V0, V1)>>,
    list_ac: &mut Vec<(V0, V1)>,
) where
    V0: Eq + Hash + Clone,
    V1: Eq + Hash + Clone,
{
    let edges = g0.edges();

    for (u0, v0) in edges {
        for u1 in f.get(&u0).unwrap().clone().iter() {
            let mut total = 0;
            for v1 in f.get(&v0).unwrap().iter() {
                if g1.has_edge(u1, v1) {
                    total += 1;
                    if let Some(entry) = s_ac.get_mut(&(v0.clone(), v1.clone())) {
                        entry.push((u0.clone(), u1.clone()));
                    } else {
                        s_ac.insert((v0.clone(), v1.clone()), vec![(u0.clone(), u1.clone())]);
                    }
                }
            }
            if total == 0 {
                f.get_mut(&u0).unwrap().remove(&u1);
                if let Some(entry) = m.get_mut(&u0) {
                    entry.insert(u1.clone());
                } else {
                    let mut set = HashSet::<V1>::new();
                    set.insert(u1.clone());
                    m.insert(u0.clone(), set);
                }
                list_ac.push((u0.clone(), u1.clone()));
            } else {
                if let Some(entry) = counter.get_mut(&(u0.clone(), v0.clone())) {
                    entry.insert(u1.clone(), total);
                } else {
                    let mut map = HashMap::<V1, u32>::new();
                    map.insert(u1.clone(), total);
                    counter.insert((u0.clone(), v0.clone()), map);
                }
            }
        }
    }
}

fn ac_prune<V0, V1>(
    f: &mut HashMap<V0, Set<V1>>,
    m: &mut HashMap<V0, HashSet<V1>>,
    counter: &mut HashMap<(V0, V0), HashMap<V1, u32>>,
    s_ac: &HashMap<(V0, V1), Vec<(V0, V1)>>,
    list_ac: &mut Vec<(V0, V1)>,
    s_sac: &mut HashMap<(V0, V1), Vec<(V0, V1)>>,
    list_sac: &mut Vec<(V0, V1)>,
) where
    V0: Eq + Hash + Clone + Debug,
    V1: Eq + Hash + Clone + Debug,
{
    while !list_ac.is_empty() {
        let (j, b) = list_ac.pop().unwrap();

        if let Some(entry) = s_ac.get(&(j.clone(), b)) {
            for (i, a) in entry.iter() {
                let count = counter
                    .get_mut(&(i.clone(), j.clone()))
                    .unwrap()
                    .get_mut(&a)
                    .unwrap();
                *count -= 1;

                if *count == 0 && !m.get(&i).unwrap().contains(&a) {
                    f.get_mut(&i).unwrap().remove(a);

                    m.get_mut(&i).unwrap().insert(a.clone());

                    list_ac.push((i.clone(), a.clone()));

                    // println!("s_ac: {:?}", &s_ac);
                    // println!("s_sac: {:?}", &s_sac);
                    if let Some(entry) = s_sac.get(&(i.clone(), a.clone())) {
                        for (k, c) in entry.iter() {
                            list_sac.push((k.clone(), c.clone()));
                        }
                    }
                }
            }
        }
    }
}

fn sac_init<V0, V1>(
    g0: &AdjacencyList<V0>,
    g1: &AdjacencyList<V1>,
    f: &mut HashMap<V0, Set<V1>>,
    m: &mut HashMap<V0, HashSet<V1>>,
    counter: &mut HashMap<(V0, V0), HashMap<V1, u32>>,
    s_ac: &HashMap<(V0, V1), Vec<(V0, V1)>>,
    s_sac: &mut HashMap<(V0, V1), Vec<(V0, V1)>>,
    list_sac: &mut Vec<(V0, V1)>,
) where
    V0: Eq + Hash + Clone + Debug,
    V1: Eq + Hash + Clone + Debug,
{
    for i in g0.vertices() {
        for a in f.get(&i).unwrap().clone().iter() {
            let mut set = Set::new();
            set.insert(a.clone());

            let mut d = f.clone();
            d.insert(i.clone(), set);

            if let Some(_) = ac3_precolour(g0, g1, d.clone()) {
                for (j, l) in d.iter() {
                    for b in l.iter() {
                        // let vec = s_sac.get_mut(&(j.clone(), b.clone())).unwrap();
                        // vec.push((i.clone(), a.clone()));
                        if let Some(entry) = s_sac.get_mut(&(j.clone(), b.clone())) {
                            entry.push((i.clone(), a.clone()));
                        } else {
                            s_sac.insert((j.clone(), b.clone()), vec![(i.clone(), a.clone())]);
                        }
                    }
                }
            } else {
                f.get_mut(&i).unwrap().remove(a);

                if let Some(entry) = m.get_mut(&i) {
                    entry.insert(a.clone());
                } else {
                    let mut entry = HashSet::<V1>::new();
                    entry.insert(a.clone());
                    m.insert(i.clone(), entry);
                }

                let mut list = vec![(i.clone(), a.clone())];
                ac_prune(f, m, counter, s_ac, &mut list, s_sac, list_sac);

                if let Some(entry) = s_sac.get(&(i.clone(), a.clone())) {
                    for (k, c) in entry.iter() {
                        list_sac.push((k.clone(), c.clone()));
                    }
                }
            }
        }
    }
}

fn sac_prune<V0, V1>(
    g0: &AdjacencyList<V0>,
    g1: &AdjacencyList<V1>,
    f: &mut HashMap<V0, Set<V1>>,
    m: &mut HashMap<V0, HashSet<V1>>,
    counter: &mut HashMap<(V0, V0), HashMap<V1, u32>>,
    s_ac: &HashMap<(V0, V1), Vec<(V0, V1)>>,
    list_ac: &mut Vec<(V0, V1)>,
    s_sac: &mut HashMap<(V0, V1), Vec<(V0, V1)>>,
    list_sac: &mut Vec<(V0, V1)>,
) where
    V0: Eq + Hash + Clone + Debug,
    V1: Eq + Hash + Clone + Debug,
{
    while !list_sac.is_empty() {
        let (u0, u1) = list_sac.pop().unwrap();
        if f.get(&u0).unwrap().contains(&u1) {
            let mut set = Set::new();
            set.insert(u1.clone());

            let mut f2 = f.clone();
            f2.insert(u0.clone(), set);

            if let None = ac3_precolour(g0, g1, f.clone()) {
                f.get_mut(&u0).unwrap().remove(&u1);
                m.get_mut(&u0).unwrap().insert(u1.clone());
                ac_prune(f, m, counter, s_ac, list_ac, s_sac, list_sac);
                for elem in s_sac.get(&(u0, u1)).unwrap().iter() {
                    list_sac.push(elem.clone());
                }
            }
        }
    }
}

pub fn sac2_precolour<V0, V1>(
    g0: &AdjacencyList<V0>,
    g1: &AdjacencyList<V1>,
    mut f: HashMap<V0, Set<V1>>,
) -> Option<HashMap<V0, Set<V1>>>
where
    V0: Eq + Clone + Hash + Debug,
    V1: Eq + Clone + Hash + Debug,
{
    let mut m = HashMap::<V0, HashSet<V1>>::new();
    let mut counter = HashMap::<(V0, V0), HashMap<V1, u32>>::new();

    let mut s_ac = HashMap::<(V0, V1), Vec<(V0, V1)>>::new();
    let mut list_ac = Vec::<(V0, V1)>::new();
    let mut s_sac = HashMap::<(V0, V1), Vec<(V0, V1)>>::new();
    let mut list_sac = Vec::<(V0, V1)>::new();

    for v0 in g0.vertices() {
        if !f.contains_key(&v0) {
            f.insert(v0.clone(), g1.vertices().cloned().collect::<Set<_>>());
        }
        m.insert(v0.clone(), HashSet::<V1>::new());
    }

    println!("ac_init");
    ac_init(
        g0,
        g1,
        &mut f,
        &mut m,
        &mut counter,
        &mut s_ac,
        &mut list_ac,
    );
    println!("ac_prune");
    ac_prune(
        &mut f,
        &mut m,
        &mut counter,
        &s_ac,
        &mut list_ac,
        &mut s_sac,
        &mut list_sac,
    );
    println!("sac_init");
    sac_init(
        g0,
        g1,
        &mut f,
        &mut m,
        &mut counter,
        &s_ac,
        &mut s_sac,
        &mut list_sac,
    );
    println!("sac_prune");
    sac_prune(
        g0,
        g1,
        &mut f,
        &mut m,
        &mut counter,
        &s_ac,
        &mut list_ac,
        &mut s_sac,
        &mut list_sac,
    );
    Some(f)
}

/// A modification of `sac2_precolour` that is initialized with a list of all nodes
/// of g1 for each node in g0.
pub fn sac2<V0, V1>(g0: &AdjacencyList<V0>, g1: &AdjacencyList<V1>) -> Option<HashMap<V0, Set<V1>>>
where
    V0: Eq + Clone + Hash + Debug,
    V1: Eq + Clone + Hash + Debug,
{
    sac2_precolour(g0, g1, HashMap::new())
}

// TODO So far this assumes that the vertices of the dot are in list format, e.g. [1, 2] -> [2, 3]
/// Parses a graph from dot format into an `AdjacencyList`.
pub fn from_dot(dot: &str) -> AdjacencyList<Vec<u32>> {
    let mut list = AdjacencyList::<Vec<u32>>::new();
    let mut split_vec = dot.split_terminator('\n').collect::<Vec<_>>();
    split_vec.pop();
    split_vec.remove(0);
    let edges = split_vec
        .iter()
        .map(|x| x.split(&['[', ',', ' ', ']'][..]).collect::<Vec<_>>())
        .collect::<Vec<_>>();
    for vec in edges {
        let v1 = vec![
            vec[1].parse::<u32>().unwrap(),
            vec[3].parse::<u32>().unwrap(),
        ];
        let v2 = vec![
            vec[7].parse::<u32>().unwrap(),
            vec[9].parse::<u32>().unwrap(),
        ];
        list.add_vertex(v1.clone());
        list.add_vertex(v2.clone());
        list.add_edge(&v1, &v2);
    }

    list
}

/// Returns `true` if `g` is a core, and `false` otherwise.  A graph G is
/// called a core if every endomorphism of G is an automorphism.
///
/// # Examples
/// ```
/// let triad = Triad::from_strs("1000", "11", "0");
///
/// asserteq!(true, is_core(&triad));
/// ```
pub fn is_core<'a, V, T>(g: &'a T) -> bool
where
    &'a T: Into<AdjacencyList<V>>,
    V: Eq + Hash + Clone,
{
    for (_, v) in ac3(&g.into(), &g.into()).unwrap() {
        if v.size() != 1 {
            return false;
        }
    }
    true
}

pub fn dfs_sac_backtrack<V0, V1>(
    g0: &AdjacencyList<V0>,
    g1: &AdjacencyList<V1>,
) -> Option<HashMap<V0, V1>>
where
    V0: Eq + Clone + Hash,
    V1: Eq + Clone + Hash,
{
    let f = match ac3(g0, g1) {
        Some(v) => v,
        None => return None,
    };
    let vec = f.clone().into_iter().collect::<Vec<_>>();
    let mut backtracked = false;

    if let Some(_) = dfs_sac_backtrack_rec(g0, g1, f, vec.into_iter(), &mut backtracked) {
        if backtracked {
            return None;
        } else {
            return Some(HashMap::<_, _>::new());
        }
    } else {
        return Some(HashMap::<_, _>::new());
    }
}

fn dfs_sac_backtrack_rec<V0, V1, I>(
    g0: &AdjacencyList<V0>,
    g1: &AdjacencyList<V1>,
    f: Domains<V0, V1>,
    mut iter: I,
    backtracked: &mut bool,
) -> Option<Domains<V0, V1>>
where
    V0: Eq + Clone + Hash,
    V1: Eq + Clone + Hash,
    I: Iterator<Item = (V0, Set<V1>)>,
{
    let (u, l) = if let Some(v) = iter.next() {
        v
    } else {
        return Some(f);
    };

    for v in l.iter() {
        let mut set = Set::new();
        set.insert(v.clone());

        let mut map = f.clone();
        *map.get_mut(&u).unwrap() = set;

        if sac2_precolour(g0, g1, map.clone()).is_some() {
            return dfs_sac_backtrack_rec(g0, g1, map, iter, backtracked);
        }
    }
    *backtracked = true;
    return None;
}

impl<T, U> Mul<&AdjacencyList<U>> for &AdjacencyList<T>
where
    T: Eq + Hash + Clone,
    U: Eq + Hash + Clone,
{
    type Output = AdjacencyList<(T, U)>;

    fn mul(self, rhs: &AdjacencyList<U>) -> AdjacencyList<(T, U)> {
        let mut list = AdjacencyList::new();

        for v1 in self.vertex_iter().cloned() {
            for v2 in rhs.vertex_iter().cloned() {
                list.insert_vertex((v1.clone(), v2));
            }
        }

        for (x1, y1) in self.edge_vec().iter() {
            for (x2, y2) in rhs.edge_vec().iter() {
                list.insert_edge(&(x1.clone(), x2.clone()), &(y1.clone(), y2.clone()));
            }
        }

        list
    }
}

impl<T: Eq + Hash + Clone + FromStr> AdjacencyList<T> {
    pub fn from_edge_list(list: &str) -> Result<AdjacencyList<T>, <T as FromStr>::Err> {
        let tree = list
            .split(&[',', '[', ']', ' '][..])
            .filter(|&x| !x.is_empty())
            .collect::<Vec<_>>();

        let mut list = AdjacencyList::<T>::new();
        for (i, _) in tree.iter().enumerate().step_by(2) {
            let v1 = tree[i].parse::<T>()?;
            let v2 = tree[i + 1].parse::<T>()?;

            list.insert_vertex(v1.clone());
            list.insert_vertex(v2.clone());
            list.insert_edge(&v1, &v2);
        }
        Ok(list)
    }
}

/// A set of lists for vertices of type `V0`, implemented as a wrapper struct
/// around a `HashMap<V0, List<V1>>`.
#[derive(Clone, Debug, Default)]
pub struct Lists<V0: Eq + Hash, V1: Eq + Hash> {
    lists: HashMap<V0, List<V1>>,
}

impl<V0: Eq + Hash, V1: Eq + Hash> Lists<V0, V1> {
    /// Creates a new, empty set of lists.
    pub fn new() -> Lists<V0, V1> {
        Lists {
            lists: HashMap::<V0, List<V1>>::new(),
        }
    }

    /// Inserts a vertex-list pair into the map.
    ///
    /// If the map did not have this vertex present, [`None`] is returned.
    ///
    /// If the map did have this vertex present, the list is updated, and the old
    /// list is returned. The vertex is not updated, though; this matters for
    /// types that can be `==` without being identical.
    pub fn insert(&mut self, v: V0, d: List<V1>) -> Option<List<V1>> {
        self.lists.insert(v, d)
    }

    /// An iterator visiting all variable-list pairs in arbitrary order.
    /// The iterator element type is `(&'a V0, &'a Set<V1>)`.
    ///
    pub fn iter<'a>(&'a self) -> impl Iterator<Item = (&V0, &List<V1>)> + 'a {
        self.lists.iter()
    }

    /// An iterator visiting all lists in arbitrary order.
    /// The iterator element type is `&'a Set<V1>`.
    ///
    pub fn lists(&self) -> impl Iterator<Item = &List<V1>> {
        self.lists.values()
    }

    pub fn variables(&self) -> impl Iterator<Item = &V0> {
        self.lists.keys()
    }

    pub fn get(&self, v: &V0) -> Option<&List<V1>> {
        self.lists.get(v)
    }

    pub fn get_mut(&mut self, v: &V0) -> Option<&mut List<V1>> {
        self.lists.get_mut(v)
    }

    pub fn remove(&mut self, v: &V0, w: &V1) -> bool {
        self.lists.get_mut(&v).unwrap().remove(w)
    }

    pub fn contains_variable(&self, v: &V0) -> bool {
        self.lists.contains_key(v)
    }
}

impl<V0: Eq + Hash, V1: Eq + Hash> IntoIterator for Lists<V0, V1> {
    type Item = (V0, List<V1>);
    type IntoIter = std::collections::hash_map::IntoIter<V0, List<V1>>;

    fn into_iter(self) -> Self::IntoIter {
        self.lists.into_iter()
    }
}
#+end_src

* TODO
** TODO Table
Run the above for a larger and larger number of vertices n. Make a table which contains
for each of the steps above the number of triads that passes the respective test, and
the running time spent to doing the tests. In this way, we may evaluate where the
bottleneck is in the above procedure when we want to verify Bulin’s conjecture for all
triads up to a certain size n.

** TODO Idempotence
Do all the above, but restrict to idempotent polymorphisms. In this case, we no longer
restrict our attention to core triads, but consider all triads on a given number of vertices.

** TODO Make PolymorphismFinder own a reference to the algorithm
** TODO Write tests
** TODO Generate all triads with constraint

* Results
** Times
| Knoten | sac1                            | sac_opt                         | sac1/sac_opt |
|--------+---------------------------------+---------------------------------+--------------|
|      4 | [20.853 us 20.857 us 20.860 us] | [25.945 us 25.964 us 25.995 us] |          0.8 |
|      5 | [27.746 us 27.780 us 27.833 us] | [32.526 us 32.544 us 32.566 us] |         0.85 |
|      6 | [46.482 us 46.504 us 46.535 us] | [53.890 us 53.904 us 53.917 us] |         0.86 |
|      7 | [88.444 us 88.464 us 88.484 us] | [103.31 us 103.35 us 103.40 us] |         0.85 |
|     13 | [397.25 us 397.46 us 397.68 us] | [454.68 us 454.99 us 455.34 us] |         0.87 |
|        |                                 |                                 |              |

** Misc
- Falls CSP(T) in NP => AC 1. Durchlauf Lösung bei Suche nach 3wnu
- Falls CSP(T) in P => AC = SAC?
- Falls CSP(T) in P => löst AC das CSP(T)?

** Vermutungen
- Falls für Triads AC = SAC
- && Falls Bulin stimmt
- löst AC CSP(T), falls CSP(T) in P.

* Micha
- Domains Data Structure
- When should you use Set?

* Manuel
- Top-level parallelisierung vs. SAC parallelisierung
